dt = require "darktable"
table = require "table"
os = require "os"

dt.print("Szevasz!!")

local function parse_datetime(d)
   local year
   year = string.sub(d, 1, 4)
   month = string.sub(d, 6, 7)
   day = string.sub(d, 9, 10)
   hour = string.sub(d, 12, 13)
   min = string.sub(d, 15, 16)
   sec = string.sub(d, 18, 19)
   return os.time{year=year, month=month, day=day, hour=hour, min=min, sec=sec} 
end

local function get_time_pair(image)
  kezdo = parse_datetime(image.exif_datetime_taken)
  veg = kezdo + image.exif_exposure
  return kezdo, veg
end


local function within_timediff(img1, img2, maxdiff)
  img1_beg, img1_end = get_time_pair(img1)
  img2_beg, img2_end = get_time_pair(img2)
  if (img2_beg-img1_end) < maxdiff then
    return true
  end
  return false
end

--[[
AEBChecker = {}
    def __init__(self):
        self.reset()
            
    def reset(self):
        self.ebvs = list()
       
    def __call__(self, comp_img, s_img):
        
        if 2 != s_img['Exif.Photo.ExposureMode']:
            return false
        ebv = s_img['Exif.Photo.ExposureBiasValue']
        if len(self.ebvs) != 0:
            #ebv = comp_img[key][Sequence.METADATA]['Exif.Photo.ExposureBiasValue'].value
            if ebv in self.ebvs:
                return false
        
        self.ebvs.append(ebv)
        return true
--]]

-- HDR processing starts here

local function group_images(img_list)

  elso_kep = img_list[1]
  for _, image in pairs(img_list) do
    image.group_with(image,elso_kep)
  end
  elso_kep.make_group_leader(elso_kep)
end

-- This function assumes that the images are ordered by exif time
local function group_sequences_in_selection_callback()
  dt.print_error("Indulunk")
  local img_list
  local hdr_list = {}
  local n_imgs = 0
  img_list = dt.gui.selection()
  elozo_kep = img_list[1]
  for _, image in pairs(img_list) do
    if within_timediff(elozo_kep, image, 7) then
      n_imgs = n_imgs + 1
      hdr_list[n_imgs] = image
    else
      if n_imgs > 1 then
        group_images(hdr_list)
      end
      hdr_list = {}
      n_imgs = 1
      hdr_list[n_imgs] = image
    end
    elozo_kep = image
  end
end

dt.register_event("shortcut",group_sequences_in_selection_callback,"selection test")

local function add_HDR_to_group(image, hdr_fn)

  imported_img = dt.database.import(hdr_fn)
  print(hdr_fn, imported_img.filename)
  image.group_with(imported_img, image)
  image.make_group_leader(imported_img)
end

local function HDR_from_group(image)
  local imgs
  imgs = image.get_group_members(image)
  hdr_img_path = HDR_from_image_table(imgs, image.path)
  
-- Import the HDR, add to the selection and set it as the group leader
  imported_img = dt.database.import(hdr_img_path)
  dt.print_error(imported_img.filename)
  image.group_with(imported_img, image)
  image.make_group_leader(imported_img)
end

local function HDR_from_image_table(img_table, target_path)

  local tmp_prefix = image.path.."/".."dt_hdr_tmp"
  local fn_list = {}

  for i, img in ipairs(img_table) do
    fn_list[i] = img.path.."/"..img.filename
  end
  
  return generateHDR(fn_list, target_path)
end  

-- fn_list: full path filenames
-- target_path: full path of the generated image
local function generateHDR(fn_list, target_path)
  
  local tmp_path = '/tmp'
  local tmp_prefix = tmp_path.."/".."dt_hdr_tmp"
  local pto_file, fn

  fn = fn_list[1]
  print(fn)
  pto_file = fn.sub(fn, 1, string.find(fn, '.', 1, true)).."pto"
  
  -- Build align_image_stack command
  align_image_stack_cmd = "align_image_stack -a "..tmp_prefix.." -p "..pto_file
  for i, img in ipairs(fn_list) do
      align_image_stack_cmd = align_image_stack_cmd.." "..img
  end
  dt.print_error(align_image_stack_cmd)
  os.execute(align_image_stack_cmd)

  -- Create the final image with enfuse
  dot_helye = string.find(fn, '.', 1, true)
  dt.print_error(dot_helye..fn)
  output_fn = fn.sub(fn, dot_helye-4, dot_helye-1)
  enfuse_cmd = "enfuse -o "..target_path..' '..tmp_prefix..'*'
  dt.print_error(enfuse_cmd)
  os.execute(enfuse_cmd)

-- Finally we delete the temporary files
  rm_cmd = "rm "..tmp_prefix..'*'
  dt.print_error(rm_cmd)
  os.execute(rm_cmd)

  return target_path
end

local function generate_hdr_from_table(img_table)
 
  for i, image in pairs(img_table) do
    if image.is_raw then
      if image == image.group_leader then
-- TODO: a target path-t még meg kell csinálni.
        generateHDR(image)
      end
    else
      dt.print_error(image.filename.." is raw. Skipping...")
    end
  end
end

local function generate_hdr_from_group_callback()
  local group_list

  group_list = dt.gui.selection()
  generate_hdr_from_table(group_list)
end

dt.register_event("shortcut", generate_hdr_from_group_callback, "Generate HDR of selected groups")

dt.preferences.register("generateHDR", "hdr_prefix", "string", "HDR prefix", "Prefix of HDR images generated from groups", "hdr_")
dt.preferences.register("group_sequences_in_selection", "max_diff", "integer", "Max difference in image sequences", "Max time difference to consider subsequent images as part of the same sequence ", 7, 1,100)


local function lookup_the_right_image_object(img, exported_images)
  local image, fn

  for image, fn in pairs(exported_images) do
    if img == image then
      return image
    end
  end
  return nil
end

function export_hdr(storage, exported_img_list)
  local exported_fn_table = {}

  dt.print_error("Export finished, postprocessing starts.")
 
  for image, tmp_fn in pairs(exported_img_list) do
    if image.is_raw then
      if image == image.group_leader then
        imgs = image.get_group_members(image)
        local n_fns = 0
	for i, img in ipairs(imgs) do
          good_img = lookup_the_right_image_object(img, exported_img_list)
	  exported_fn_table[i] = exported_img_list[good_img]
          dt.print_error(i..tostring(img)..','..exported_fn_table[i])
          n_fns = n_fns +1
        end
	dt.print_error(tostring(exported_fn_table))
        if n_fns > 1 then 
          hdr_fajl = generateHDR(exported_fn_table, image.path.."/HDR_"..image.filename..'.tif')
          if hdr_fajl then
            print("Uj leader: ", hdr_fajl)
            add_HDR_to_group(image, hdr_fajl)
          end 
        end
      else
        print("Nem leader:", image.filename)
      end
    else
      dt.print_error(image.filename.." is not raw. Skipping...")
    end
  end

  dt.print_error("Ennyi volt!")

end 

dt.register_storage("proba", "proba callback", nil, export_hdr)
